# !/usr/bin/env python3

import os, warnings, random
from dotenv import load_dotenv
from ase.io import read, write
from mp_api.client import MPRester
from pymatgen.core import Structure
from pymatgen.io.vasp import Poscar, Kpoints
from pymatgen.analysis.defects import generators
from pymatgen.io.vasp.sets import (
    MPStaticSet, 
    MPRelaxSet, 
    MPNonSCFSet, 
    MPScanRelaxSet, 
    MPScanStaticSet,
    MPMDSet, 
    )

from masgent import schemas
from masgent.utils import (
    os_path_setup, 
    write_comments,
    color_print,
    ask_for_mp_api_key,
    validate_mp_api_key,
    )

# Do not show warnings
warnings.filterwarnings('ignore')

# Track whether Materials Project key has been checked during this process
_mp_key_checked = False

def generate_vasp_poscar(input: schemas.GenerateVaspPoscarSchema) -> str:
    '''
    Generate VASP POSCAR file from user inputs or from Materials Project database.
    '''
    color_print(f'[Debug: Function Calling] generate_vasp_poscar with input: {input}', 'green')
    
    formula = input.formula

    try:
        base_dir, output_dir = os_path_setup()

        # Ensure Materials Project API key exists and validate it only once per process
        load_dotenv(dotenv_path='.env')

        global _mp_key_checked
        if not _mp_key_checked:
            if 'MP_API_KEY' not in os.environ:
                ask_for_mp_api_key()
            else:
                color_print('[Info] Materials Project API key found in environment.\n', 'green')
                validate_mp_api_key(os.environ['MP_API_KEY'])
            _mp_key_checked = True
        
        with MPRester() as mpr:
            docs = mpr.materials.summary.search(formula=formula)
            if not docs:
                return f'\nNo materials found in Materials Project database for formula: {formula}'
            
            mid = docs[0].material_id   # pick the first match
            structure = mpr.get_structure_by_material_id(mid)
            poscar = Poscar(structure)

        # Also write to the main target directory for easy access
        poscar.write_file(os.path.join(output_dir, 'POSCAR'), direct=True)

        comments = f'# Generated by Masgent from Materials Project entry {mid}.'
        write_comments(os.path.join(output_dir, 'POSCAR'), 'poscar', comments)

        return f'\nUpdated POSCAR in {output_dir}.'

    except Exception as e:
        return f'\nPOSCAR generation failed: {str(e)}'
    
def generate_vasp_inputs_from_poscar(input: schemas.GenerateVaspInputsFromPoscar) -> str:
    '''
    Generate VASP input files (INCAR, KPOINTS, POTCAR) using pymatgen input sets.
    '''
    color_print(f'[Debug: Function Calling] generate_vasp_inputs_from_poscar with input: {input}', 'green')
    
    poscar_path = input.poscar_path
    vasp_input_sets = input.vasp_input_sets

    VIS_MAP = {
        'MPRelaxSet': MPRelaxSet,
        'MPStaticSet': MPStaticSet,
        'MPNonSCFSet': MPNonSCFSet,
        'MPScanRelaxSet': MPScanRelaxSet,
        'MPScanStaticSet': MPScanStaticSet,
        'MPMDSet': MPMDSet,
    }
    vis_class = VIS_MAP[vasp_input_sets]

    try:
        base_dir, output_dir = os_path_setup()
        
        structure = Structure.from_file(poscar_path)
        vis = vis_class(structure)

        vis.incar.write_file(os.path.join(output_dir, 'INCAR'))
        vis.poscar.write_file(os.path.join(output_dir, 'POSCAR'), direct=True)
        vis.kpoints.write_file(os.path.join(output_dir, 'KPOINTS'))
        vis.potcar.write_file(os.path.join(output_dir, 'POTCAR'))

        incar_comments = f'# Generated by Masgent using {vasp_input_sets} set provided by Materials Project.'
        write_comments(os.path.join(output_dir, 'INCAR'), 'incar', incar_comments)
        kpoints_comments = f'# Generated by Masgent using {vasp_input_sets} set provided by Materials Project.'
        write_comments(os.path.join(output_dir, 'KPOINTS'), 'kpoints', kpoints_comments)
        poscar_comments = f'# Generated by Masgent using {vasp_input_sets} set provided by Materials Project.'
        write_comments(os.path.join(output_dir, 'POSCAR'), 'poscar', poscar_comments)
        
        return f'\nUpdated VASP input files based on {vasp_input_sets} in {output_dir}.'
    
    except Exception as e:
        return f'\nVASP input files generation failed: {str(e)}'
    
def convert_structure_format(input: schemas.ConvertStructureFormatSchema) -> str:
    '''
    Convert structure files between different formats (CIF, POSCAR, XYZ).
    '''
    color_print(f'[Debug: Function Calling] convert_structure_format with input: {input}', 'green')
    
    input_path = input.input_path
    input_format = input.input_format
    output_format = input.output_format
    
    format_map = {
        "POSCAR": "vasp",
        "CIF": "cif",
        "XYZ": "xyz"
    }

    try:
        base_dir, output_dir = os_path_setup()
        
        atoms = read(input_path, format=format_map[input_format])
        filename_wo_ext = os.path.splitext(os.path.basename(input_path))[0]
        # Ignore the POSCAR, do not add extension
        if output_format == 'POSCAR':
            output_path = os.path.join(output_dir, 'POSCAR')
        else:
            output_path = os.path.join(output_dir, f'{filename_wo_ext}.{output_format.lower()}')
        write(output_path, atoms, format=format_map[output_format])

        return f'\nConverted structure saved to {output_path}.'
    
    except Exception as e:
        return f'\nStructure conversion failed: {str(e)}'
    
def convert_poscar_coordinates(input: schemas.ConvertPoscarCoordinatesSchema) -> str:
    '''
    Convert POSCAR between direct and cartesian coordinates.
    '''
    color_print(f'[Debug: Function Calling] convert_poscar_coordinates with input: {input}', 'green')
    
    poscar_path = input.poscar_path
    to_cartesian = input.to_cartesian

    try:
        base_dir, output_dir = os_path_setup()
        
        structure = Structure.from_file(poscar_path)
        poscar = Poscar(structure)
        poscar.write_file(os.path.join(output_dir, 'POSCAR_converted'), direct=not to_cartesian)

        coord_type = 'Cartesian' if to_cartesian else 'Direct'
        comments = f'# Generated by Masgent converted to {coord_type} coordinates.'
        write_comments(os.path.join(output_dir, 'POSCAR_converted'), 'poscar', comments)

        return f'\nConverted POSCAR to {coord_type} coordinates in {output_dir}.'

    except Exception as e:
        return f'\nPOSCAR coordinate conversion failed: {str(e)}'
    
def customize_vasp_kpoints_with_accuracy(input: schemas.CustomizeVaspKpointsWithAccuracy) -> str:
    '''
    Customize VASP KPOINTS from POSCAR with specified accuracy level.
    '''
    color_print(f'[Debug: Function Calling] customize_vasp_kpoints_with_accuracy with input: {input}', 'green')
    
    poscar_path = input.poscar_path
    accuracy_level = input.accuracy_level
    
    DENSITY_MAP = {
        'Low': 1000,
        'Medium': 3000,
        'High': 5000,
    }
    kppa = DENSITY_MAP[accuracy_level]

    try:
        base_dir, output_dir = os_path_setup()
        
        structure = Structure.from_file(poscar_path)
        kpoints = Kpoints.automatic_density(structure, kppa=kppa)
        kpoints.write_file(os.path.join(output_dir, f'KPOINTS_{accuracy_level.lower()}'))

        comments = f'# Generated by Masgent with {accuracy_level} accuracy (Grid Density = {kppa} / number of atoms)'
        write_comments(os.path.join(output_dir, f'KPOINTS_{accuracy_level.lower()}'), 'kpoints', comments)
        
        return f'\nUpdated KPOINTS with {accuracy_level} accuracy in {output_dir}.'

    except Exception as e:
        return f'\nVASP KPOINTS generation failed: {str(e)}'
    
def generate_vasp_poscar_with_defects(input: schemas.GenerateVaspPoscarWithDefects) -> str:
    '''
    Generate VASP POSCAR with defects: vacancies, substitutions, and interstitials with Voronoi method.
    '''
    color_print(f'[Debug: Function Calling] generate_vasp_poscar_with_defects with input: {input}', 'green')

    poscar_path = input.poscar_path
    defect_type = input.defect_type
    original_element = input.original_element
    defect_element = input.defect_element
    defect_amount = input.defect_amount

    try:
        base_dir, output_dir = os_path_setup()
        
        atoms = read(poscar_path, format='vasp')

        if defect_type == 'vacancy' or defect_type == 'substitution':
            all_indices = [i for i, atom in enumerate(atoms) if atom.symbol == original_element]
            if isinstance(defect_amount, float):
                num_defects = max(1, int(defect_amount * len(all_indices)))
            elif isinstance(defect_amount, int):
                num_defects = defect_amount

        if defect_type in {'vacancy', 'substitution'}:
            if defect_type == 'vacancy':
                vacancy_indices = random.sample(all_indices, num_defects)
                del atoms[vacancy_indices]
            elif defect_type == 'substitution':
                substitution_indices = random.sample(all_indices, num_defects)
                for i in substitution_indices:
                    atoms[i].symbol = defect_element
            write(os.path.join(output_dir, f'POSCAR_{defect_type}'), atoms, format='vasp', direct=True, sort=True)
            comments = f'# Generated by Masgent with {defect_type} defect, be careful to verify structure.'
            write_comments(os.path.join(output_dir, f'POSCAR_{defect_type}'), 'poscar', comments)

        if defect_type == 'interstitial (Voronoi)':
            # Read atoms from ASE and convert to Pymatgen Structure
            structure = Structure.from_ase_atoms(atoms)
            interstitial_generator = generators.VoronoiInterstitialGenerator().generate(structure=structure, insert_species=[defect_element])
            defect_sites, defect_structures = [], []
            for defect in interstitial_generator:
                defect_sites.append(defect.site.frac_coords)
                defect_structures.append(defect.defect_structure)

            if len(defect_structures) == 0:
                return f'\nNo interstitial sites found for element {defect_element}.'
            else:
                for i, defect_structure in enumerate(defect_structures):
                    # Convert back to ASE Atoms for writing
                    defect_atoms = defect_structure.to_ase_atoms()
                    write(os.path.join(output_dir, f'POSCAR_interstitial_{i}'), defect_atoms, format='vasp', direct=True, sort=True)
                    comments = f'# Generated by Masgent with interstitial (Voronoi) defect of element {defect_element} at fract. coords {defect_sites[i]}, be careful to verify structure.'
                    write_comments(os.path.join(output_dir, f'POSCAR_interstitial_{i}'), 'poscar', comments)

        return f'\nGenerated POSCAR with {defect_type} defects in {os.path.join(output_dir, "POSCAR")}.'
    
    except Exception as e:
        return f'\nVASP POSCAR defect generation failed: {str(e)}'
    
def generate_supercell_from_poscar(input: schemas.GenerateSupercellFromPoscar) -> str:
    '''
    Generate supercell from POSCAR based on user-defined scaling matrix.
    '''
    color_print(f'[Debug: Function Calling] generate_supercell_from_poscar with input: {input}', 'green')
    
    poscar_path = input.poscar_path
    scaling_matrix = input.scaling_matrix

    scaling_matrix_ = [
        [int(num) for num in line.strip().split()] 
        for line in scaling_matrix.split(';')
        ]

    try:
        base_dir, output_dir = os_path_setup()
        
        structure = Structure.from_file(poscar_path).copy()
        supercell_structure = structure.make_supercell(scaling_matrix_)
        supercell_poscar = Poscar(supercell_structure)
        supercell_poscar.write_file(os.path.join(output_dir, 'POSCAR_supercell'), direct=True)

        comments = f'# Generated by Masgent as supercell with scaling matrix {scaling_matrix}.'
        write_comments(os.path.join(output_dir, 'POSCAR_supercell'), 'poscar', comments)

        return f'\nGenerated supercell POSCAR in {output_dir}.'
    
    except Exception as e:
        return f'\nSupercell generation failed: {str(e)}'